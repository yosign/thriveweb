<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel 打印单生成工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS for reading source data -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <!-- ExcelJS for modifying template -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    <style>
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-8">

    <div class="max-w-2xl mx-auto bg-white rounded-lg shadow-md p-8">
        <h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Excel 打印单自动生成工具</h1>
        
        <div class="space-y-6">
            <!-- 源数据文件上传 -->
            <div class="bg-blue-50 p-4 rounded border border-blue-100">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    1. 上传源数据 (例如: 金中华水产1201-1207.xlsx)
                </label>
                <input type="file" id="sourceFile" accept=".xlsx" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-500 file:text-white
                    hover:file:bg-blue-600
                "/>
                <p class="text-xs text-gray-500 mt-1">需包含 Sheet1 和 Sheet2，第2行为表头。</p>
            </div>

            <!-- 模板文件上传 -->
            <div class="bg-green-50 p-4 rounded border border-green-100">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    2. 上传模板文件 (例如: 副本打印单.xlsx)
                </label>
                <input type="file" id="templateFile" accept=".xlsx" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-green-500 file:text-white
                    hover:file:bg-green-600
                "/>
                <p class="text-xs text-gray-500 mt-1">需包含 "销售单" Sheet。</p>
            </div>

            <!-- 操作按钮 -->
            <div class="flex flex-col items-center justify-center pt-4">
                <button id="processBtn" class="bg-indigo-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2">
                    <span>生成并下载</span>
                    <div id="loader" class="loader"></div>
                </button>
                <div id="statusMsg" class="mt-4 text-sm text-gray-600 min-h-[20px]"></div>
            </div>
        </div>

        <div class="mt-8 border-t pt-4 text-gray-400 text-xs">
            <p>使用说明：</p>
            <ul class="list-disc list-inside mt-2 space-y-1">
                <li>源数据必须包含 "存货名称" 和 "单位" 列。</li>
                <li>模板中必须包含 "收货单位：" 标记和 "行号" 行。</li>
                <li>所有处理均在本地浏览器完成，不会上传数据到服务器。</li>
            </ul>
        </div>
    </div>

    <script>
        // 配置常量 (对应 Python 脚本中的配置)
        const CONFIG = {
            LABEL_COL_IDX: 0, // A列
            NAME_COL_IDX: 1,  // B列
            UNIT_COL_IDX: 3,  // D列
            QTY_COL_IDX: 5,   // F列
            
            SOURCE_SHEET1: "Sheet1",
            SOURCE_SHEET2: "Sheet2",
            TEMPLATE_SHEET: "销售单",
            
            COL_NAME: "存货名称",
            COL_UNIT: "单位"
        };

        const statusMsg = document.getElementById('statusMsg');
        const loader = document.getElementById('loader');
        const processBtn = document.getElementById('processBtn');

        function log(msg, isError = false) {
            statusMsg.textContent = msg;
            statusMsg.className = isError ? "mt-4 text-sm text-red-600" : "mt-4 text-sm text-gray-600";
            console.log(msg);
        }

        // 工具：读取文件为 ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsArrayBuffer(file);
            });
        }

        // 核心逻辑：处理源数据
        function processSourceData(workbook) {
            const sheets = [CONFIG.SOURCE_SHEET1, CONFIG.SOURCE_SHEET2];
            const allData = []; // 存储所有行对象: {name: "x", unit: "y", canteenA: 10, canteenB: 20...}
            
            sheets.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                // 使用 header:1 读取为二维数组
                // Python 逻辑: 
                // header = s1_raw.iloc[1] (索引1，即第2行)
                // data = s1_raw.iloc[2:] (索引2开始，即第3行开始)
                const rawData = XLSX.utils.sheet_to_json(sheet, {header: 1});
                
                if (rawData.length < 2) return;

                const headers = rawData[1]; // 第2行是表头
                const dataRows = rawData.slice(2); // 第3行开始是数据

                // 找到关键列的索引
                const nameIdx = headers.indexOf(CONFIG.COL_NAME);
                const unitIdx = headers.indexOf(CONFIG.COL_UNIT);

                if (nameIdx === -1 || unitIdx === -1) {
                    console.warn(`Sheet ${sheetName} 缺少关键列`);
                    return;
                }

                dataRows.forEach(row => {
                    const name = row[nameIdx];
                    const unit = row[unitIdx];
                    
                    if (!name) return; // 跳过没有名称的行

                    // 构建行对象，键为表头名称
                    const rowObj = {};
                    headers.forEach((h, i) => {
                        if (h) rowObj[h] = row[i];
                    });
                    allData.push(rowObj);
                });
            });

            return allData;
        }

        // 获取指定食堂的商品列表
        function getItemsForCanteen(canteenName, allData) {
            // 过滤出该食堂有数据的行
            const items = allData.filter(row => {
                const val = row[canteenName];
                // 转数字逻辑
                const num = parseFloat(val);
                return !isNaN(num) && num !== 0;
            }).map(row => ({
                name: row[CONFIG.COL_NAME],
                unit: row[CONFIG.COL_UNIT],
                qty: parseFloat(row[canteenName])
            }));

            // 合并相同商品 (groupby)
            const grouped = {};
            items.forEach(item => {
                const key = `${item.name}|${item.unit}`;
                if (!grouped[key]) {
                    grouped[key] = { name: item.name, unit: item.unit, qty: 0 };
                }
                grouped[key].qty += item.qty;
            });

            // 转回数组并按名称排序
            return Object.values(grouped).sort((a, b) => {
                return (a.name || "").localeCompare(b.name || "");
            });
        }

        processBtn.addEventListener('click', async () => {
            const sourceFile = document.getElementById('sourceFile').files[0];
            const templateFile = document.getElementById('templateFile').files[0];

            if (!sourceFile || !templateFile) {
                log("请同时选择源文件和模板文件", true);
                return;
            }

            try {
                processBtn.disabled = true;
                loader.style.display = "inline-block";
                log("正在读取文件...");

                // 1. 读取源文件
                const sourceBuffer = await readFileAsArrayBuffer(sourceFile);
                const sourceWb = XLSX.read(sourceBuffer, {type: 'array'});
                
                const allData = processSourceData(sourceWb);
                log(`源数据读取完成，共找到 ${allData.length} 条原始记录`);

                // 2. 读取模板文件 (使用 ExcelJS)
                const templateBuffer = await readFileAsArrayBuffer(templateFile);
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(templateBuffer);
                
                const worksheet = workbook.getWorksheet(CONFIG.TEMPLATE_SHEET);
                if (!worksheet) {
                    throw new Error(`模板中找不到 "${CONFIG.TEMPLATE_SHEET}" Sheet`);
                }

                log("正在填充模板...");

                // 3. 遍历模板填充数据
                // ExcelJS 行号从1开始
                const rowCount = worksheet.rowCount;
                
                // 1-based index adjustment for ExcelJS
                const labelColIdx = CONFIG.LABEL_COL_IDX + 1;
                const nameColIdx = CONFIG.NAME_COL_IDX + 1;
                const unitColIdx = CONFIG.UNIT_COL_IDX + 1;
                const qtyColIdx = CONFIG.QTY_COL_IDX + 1;

                let i = 1;
                while (i <= rowCount) {
                    const labelCell = worksheet.getCell(i, labelColIdx);
                    const labelVal = labelCell.value ? labelCell.value.toString().trim() : "";

                    // 找到 "收货单位："
                    if (labelVal === "收货单位：") {
                        const nameCell = worksheet.getCell(i, nameColIdx); // 假设食堂名字在 B 列
                        const fullCanteen = nameCell.value ? nameCell.value.toString() : "";
                        const canteen = fullCanteen.replace("食堂", "").trim();
                        
                        // 获取该食堂数据
                        const items = getItemsForCanteen(canteen, allData);
                        // console.log(`处理食堂: ${canteen}, 找到 ${items.length} 条记录`);

                        // 找 "行号"
                        let j = i + 1;
                        while (j <= rowCount) {
                            const cell = worksheet.getCell(j, labelColIdx);
                            const val = cell.value ? cell.value.toString().trim() : "";
                            if (val === "行号") break;
                            j++;
                        }

                        if (j > rowCount) break; // 没找到行号

                        // 开始填充数据
                        let k = j + 1;
                        let itemIdx = 0;

                        while (k <= rowCount) {
                            const rowLabelCell = worksheet.getCell(k, labelColIdx);
                            const rowLabelVal = rowLabelCell.value ? rowLabelCell.value.toString() : "";

                            if (rowLabelVal.startsWith("合计金额")) break;

                            // 判断是否是数据行 (看行号列是否是数字)
                            let isLine = false;
                            // 简单判断：如果是数字，或者能转成数字
                            if (!isNaN(parseFloat(rowLabelVal))) {
                                isLine = true;
                            }

                            if (isLine) {
                                if (itemIdx < items.length) {
                                    const item = items[itemIdx];
                                    worksheet.getCell(k, nameColIdx).value = item.name;
                                    worksheet.getCell(k, unitColIdx).value = item.unit;
                                    worksheet.getCell(k, qtyColIdx).value = item.qty;
                                } else {
                                    // 清空多余行
                                    worksheet.getCell(k, nameColIdx).value = null;
                                    worksheet.getCell(k, unitColIdx).value = null;
                                    worksheet.getCell(k, qtyColIdx).value = null;
                                }
                                itemIdx++;
                            }
                            k++;
                        }

                        i = k; // 跳过已处理的块
                    } else {
                        i++;
                    }
                }

                // 4. 导出文件
                log("正在生成文件...");
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
                
                // 创建下载链接
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "副本打印单_整理后.xlsx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                log("处理完成！文件已开始下载。");

            } catch (err) {
                console.error(err);
                log("发生错误: " + err.message, true);
            } finally {
                processBtn.disabled = false;
                loader.style.display = "none";
            }
        });
    </script>
</body>
</html>

